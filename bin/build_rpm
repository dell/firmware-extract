#!/usr/bin/python
# vim:expandtab:autoindent:tabstop=4:shiftwidth=4:filetype=python:

  #############################################################################
  #
  # Copyright (c) 2005 Dell Computer Corporation
  # Dual Licenced under GNU GPL and OSL
  #
  #############################################################################
"""build_rpm: 

usage:
    -h | --help         print this message
    -f | --force        where cd is mounted
*   -i | --input_dir    dir containing packages
*   -b | --build_dir    where to build RPMS (output to RPMS/noarch/)
*   -s | --spec_dir     directory containing spec files to use

-- Required parameters are denoted by an asterisk (*)

"""

from __future__ import generators

version = "1.6"

# import arranged alphabetically
import commands
import getopt
import glob
import os
import sys
import ConfigParser
import traceback

import firmwaretools.pycompat  as pycompat
import firmwaretools.HelperXml as HelperXml
import firmwaretools.biosHdr   as biosHdr
import firmwaretools.repository as repository

class NonExistentSpecFile(Exception): pass
class RpmBuildFailed(Exception): pass

def safemkdir(dest):
    try:
        os.makedirs( dest )
    except OSError: #already exists
        pass

def getSpecName(ini, specDir):
    specName = ini.get("package", "spec")
    specFile = os.path.join(specDir, "%s_spec.in" % specName)
    if not os.path.exists(specFile):
        raise NonExistentSpecFile("spec file %s does not exist." % specFile)
    return specFile

def getSpecRelease(specFileName):
    rel = "0"
    fd = open(specFileName, "r")
    while 1:
        line = fd.readline()
        if line == "": break
        if line.startswith("Release"):
            txt, rel = line.split(":",1)
            rel = rel.strip()
    fd.close()
    return rel

def makeTarball(ini, pkgDir, buildDir):
    if ini.has_option("package", "rpm_version"):
        ver = ini.get("package", "rpm_version")
    else:
        ver = ini.get("package", "version")
        
    tarballName = "%s-%s.tar.bz2" % (ini.get("package", "safe_name"), ver)
    tarballFullPath = os.path.join(buildDir, "SOURCES", tarballName)
    tarballRoot = os.path.join(pkgDir, "..")
    cmd = "tar cjf %s -C %s %s " % (tarballFullPath, tarballRoot, os.path.basename(pkgDir))
    pycompat.executeCommand(cmd)
    return tarballName

buildString = "BUILT. EXTRACT(%s) BUILD_RPM(%s). SPEC_REVISION(%s)"
def makeRpm(pkgDir, buildDir, specDir, forceRebuild):
    packageIni = ConfigParser.ConfigParser()
    packageIni.read( os.path.join(pkgDir, "package.ini"))

    print "attempt build: %s version %s" % (packageIni.get("package", "name"), packageIni.get("package", "version")),
    sys.stdout.flush()

    try:
        specFileName = getSpecName(packageIni, specDir)
        specRelease = getSpecRelease(specFileName)
        oldSpecRelease = "0"
        if packageIni.has_option("package", "spec_revision"):
            oldSpecRelease = packageIni.get("package", "spec_revision")
    except (NonExistentSpecFile), e:
        print "No SPEC file for module: %s_spec.in" % packageIni.get("package", "spec")
        return 0

    extractVersion = packageIni.get("package", "extract_ver")

    # check if any version of anything that contributes to final output has changed.
    # if any version changes, we rebuild.
    if not forceRebuild and packageIni.has_option("package", "rpm_build"):
        rpmBuild = packageIni.get("package", "rpm_build")
        if rpmBuild == buildString % (extractVersion, version, specRelease):
            print " Already processed."
            return 1

    packageIni.set("package", "rpm_build", buildString % (extractVersion, version, specRelease))

    # monotonically increasing revision. Every rebuild for whatever reason bumps this.
    # if package release changes, reset revision to 1
    revision = 0
    if packageIni.has_option("package", "revision") and specRelease == oldSpecRelease:
        revision = packageIni.getint("package", "revision")
    revision = revision + 1

    packageIni.set("package", "revision", str(revision))
    packageIni.set("package", "spec_revision", specRelease)

    tarballName = makeTarball( packageIni, pkgDir, buildDir )

    cmd = """rpmbuild --define "_topdir %s" """ % buildDir
    for option in packageIni.options("package"):
        value = packageIni.get("package", option)
        if not value: continue
        cmd = cmd + """  --define "%s %s" """ % (option, value)

    cmd = cmd + """  -bb %s > %s 2>&1""" % (specFileName, os.path.join(buildDir, "BUILD", tarballName + "-LOG" ))
    if pycompat.executeCommand(cmd):
        raise RpmBuildFailed("RPM build command failed.")

    # in case file is a hardlink, unlink to break it first.
    try:
        os.unlink( os.path.join(pkgDir, "package.ini") )
    except OSError:  # nonexistent
        pass
    fd = open(os.path.join(pkgDir, "package.ini"), "w+")
    packageIni.write(fd)
    fd.close()
    print "  GOOD."


forceRebuild = 0
def main():
    inputDir = None
    buildDir = None
    specDir = None
    forceRebuild = 0

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hi:b:s:f", [
                "help", "input_dir=", "build_dir=", "spec_dir=", "force"
            ])
        for option, argument in opts:
            if option in ("-h", "--help"):
                print __doc__
                sys.exit(0)
            if option in ("-i", "--input_dir"):
                inputDir = os.path.realpath(argument)
            if option in ("-b", "--build_dir"):
                buildDir = os.path.realpath(argument)
            if option in ("-s", "--spec_dir"):
                specDir = os.path.realpath(argument)
            if option in ("-f", "--force"):
                forceRebuild = 1

        if buildDir is None: raise getopt.GetoptError("Need output dir", "")

        safemkdir(buildDir)
        oldpwd = os.getcwd()
        os.chdir(buildDir)
        for i in ("RPMS", "BUILD", "SOURCES", ): 
            safemkdir(i)

        packageDirs = []
        filteredList = []
        dirsToProcess=os.listdir(inputDir)
        dirsToProcess=[d for d in dirsToProcess if os.path.isdir(os.path.join(inputDir,d))]

        for d in dirsToProcess:
            for topdir, dirlist, filelist in pycompat.walkPath(os.path.join(inputDir,d)):
                if "package.ini" in filelist:
                    packageDirs.append(topdir)
                    
        # only generate RPMS for the latest one. no use wasting time.
        print "Startup build_rpm... reading package configuration..."
        sys.stdout.flush()
        repo = repository.Repository( *packageDirs )
        for pkg in repo.iterLatestPackages():
            try:
                makeRpm(pkg.path, buildDir, specDir, forceRebuild)
            except (KeyboardInterrupt):
                raise
            except:
                traceback.print_exc()
                pass

        os.chdir(oldpwd)

    except (getopt.GetoptError):
        # print help information and exit:
        print __doc__
        sys.exit(2)

    except (KeyboardInterrupt):
        try:
            os.wait()
        except OSError:
            pass
        sys.exit(3)

    return 0 #shell logic



if __name__ == "__main__":
    sys.exit( main() )
