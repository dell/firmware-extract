#!/usr/bin/python
# vim:expandtab:autoindent:tabstop=4:shiftwidth=4:filetype=python:

  #############################################################################
  #
  # Copyright (c) 2005 Dell Computer Corporation
  # Dual Licenced under GNU GPL and OSL
  #
  #############################################################################
"""build_rpm: 

usage:
    -h | --help         print this message
    -f | --force        where cd is mounted
*   -i | --input_dir    dir containing packages
*   -b | --build_dir    where to build RPMS (output to RPMS/noarch/)
*   -s | --spec_dir     directory containing spec files to use

-- Required parameters are denoted by an asterisk (*)

"""

from __future__ import generators

version = "1.6"

# import arranged alphabetically
import commands
import getopt
import glob
import os
import sys
import ConfigParser
import traceback

import firmwaretools.pycompat  as pycompat
import firmware_addon_dell.HelperXml as HelperXml
import firmware_addon_dell.biosHdr   as biosHdr
import firmwaretools.repository as repository

class NonExistentSpecFile(Exception): pass
class RpmBuildFailed(Exception): pass

def safemkdir(dest):
    try:
        os.makedirs( dest )
    except OSError: #already exists
        pass

def getSpecName(ini, specDir):
    specName = ini.get("package", "spec")
    specFile = os.path.join(specDir, "%s_spec.in" % specName)
    if not os.path.exists(specFile):
        raise NonExistentSpecFile("spec file %s does not exist." % specFile)
    return specFile

def getSpecRelease(specFileName):
    rel = "0"
    fd = open(specFileName, "r")
    while 1:
        line = fd.readline()
        if line == "": break
        if line.startswith("Release"):
            txt, rel = line.split(":",1)
            rel = rel.strip()
    fd.close()
    return rel

def makeTarball(ini, pkgDir, buildDir):
    if ini.has_option("package", "rpm_version"):
        ver = ini.get("package", "rpm_version")
    else:
        ver = ini.get("package", "version")
        
    tarballName = "%s-%s.tar.bz2" % (ini.get("package", "safe_name"), ver)
    tarballFullPath = os.path.join(buildDir, "SOURCES", tarballName)
    tarballRoot = os.path.join(pkgDir, "..")
    cmd = "tar cjf %s -C %s %s " % (tarballFullPath, tarballRoot, os.path.basename(pkgDir))
    pycompat.executeCommand(cmd)
    return tarballName

buildString = "BUILT. EXTRACT(%s) BUILD_RPM(%s). SPEC_REVISION(%s)"
def makeRpm(pkgDir, buildDir, specDir, forceRebuild):
    packageIni = ConfigParser.ConfigParser()
    packageIni.read( os.path.join(pkgDir, "package.ini"))

    print "attempt build: %s version %s" % (packageIni.get("package", "name"), packageIni.get("package", "version")),
    sys.stdout.flush()

    try:
        specFileName = getSpecName(packageIni, specDir)
        specRelease = getSpecRelease(specFileName)
        oldSpecRelease = "0"
        if packageIni.has_option("package", "spec_revision"):
            oldSpecRelease = packageIni.get("package", "spec_revision")
    except (NonExistentSpecFile), e:
        print "No SPEC file for module: %s_spec.in" % packageIni.get("package", "spec")
        return 0

    extractVersion = packageIni.get("package", "extract_ver")

    # check if any version of anything that contributes to final output has changed.
    # if any version changes, we rebuild.
    if not forceRebuild and packageIni.has_option("package", "rpm_build"):
        rpmBuild = packageIni.get("package", "rpm_build")
        if rpmBuild == buildString % (extractVersion, version, specRelease):
            print " Already processed."
            return 1

    packageIni.set("package", "rpm_build", buildString % (extractVersion, version, specRelease))

    # monotonically increasing revision. Every rebuild for whatever reason bumps this.
    # if package release changes, reset revision to 1
    revision = 0
    if packageIni.has_option("package", "revision") and specRelease == oldSpecRelease:
        revision = packageIni.getint("package", "revision")
    revision = revision + 1

    packageIni.set("package", "revision", str(revision))
    packageIni.set("package", "spec_revision", specRelease)

    tarballName = makeTarball( packageIni, pkgDir, buildDir )

    cmd = """rpmbuild --define "_topdir %s" """ % buildDir
    for option in packageIni.options("package"):
        value = packageIni.get("package", option)
        if not value: continue
        cmd = cmd + """  --define "%s %s" """ % (option, value)

    cmd = cmd + """  -bb %s > %s 2>&1""" % (specFileName, os.path.join(buildDir, "BUILD", tarballName + "-LOG" ))
    if pycompat.executeCommand(cmd):
        raise RpmBuildFailed("RPM build command failed.")

    # in case file is a hardlink, unlink to break it first.
    try:
        os.unlink( os.path.join(pkgDir, "package.ini") )
    except OSError:  # nonexistent
        pass
    fd = open(os.path.join(pkgDir, "package.ini"), "w+")
    packageIni.write(fd)
    fd.close()
    print "  GOOD."


forceRebuild = 0
def main():
    inputDir = None
    buildDir = None
    specDir = None
    forceRebuild = 0

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hi:b:s:f", [
                "help", "input_dir=", "build_dir=", "spec_dir=", "force"
            ])
        for option, argument in opts:
            if option in ("-h", "--help"):
                print __doc__
                sys.exit(0)
            if option in ("-i", "--input_dir"):
                inputDir = os.path.realpath(argument)
            if option in ("-b", "--build_dir"):
                buildDir = os.path.realpath(argument)
            if option in ("-s", "--spec_dir"):
                specDir = os.path.realpath(argument)
            if option in ("-f", "--force"):
                forceRebuild = 1

        if buildDir is None: raise getopt.GetoptError("Need output dir", "")

        safemkdir(buildDir)
        oldpwd = os.getcwd()
        os.chdir(buildDir)
        for i in ("RPMS", "BUILD", "SOURCES", ): 
            safemkdir(i)

        packageDirs = []
        filteredList = []
        dirsToProcess=os.listdir(inputDir)
        dirsToProcess=[d for d in dirsToProcess if os.path.isdir(os.path.join(inputDir,d))]

        for d in dirsToProcess:
            for topdir, dirlist, filelist in pycompat.walkPath(os.path.join(inputDir,d)):
                if "package.ini" in filelist:
                    packageDirs.append(topdir)
                    
        # only generate RPMS for the latest one. no use wasting time.
        print "Startup build_rpm... reading package configuration..."
        sys.stdout.flush()
        repo = repository.Repository( *packageDirs )
        for pkg in repo.iterLatestPackages():
            try:
                makeRpm(pkg.path, buildDir, specDir, forceRebuild)
            except (KeyboardInterrupt):
                raise
            except:
                traceback.print_exc()
                pass

        os.chdir(oldpwd)

    except (getopt.GetoptError):
        # print help information and exit:
        print __doc__
        sys.exit(2)

    except (KeyboardInterrupt):
        try:
            os.wait()
        except OSError:
            pass
        sys.exit(3)

    return 0 #shell logic



if __name__ == "__main__":
    sys.exit( main() )
