#!/usr/bin/python
# vim:tw=0:expandtab:autoindent:tabstop=4:shiftwidth=4:filetype=python:

  #############################################################################
  #
  # Copyright (c) 2005-2007 Dell, Inc.
  # Dual Licenced under GNU GPL and OSL
  #
  #############################################################################
"""extract_hdr:

usage:
    -h | --help         print this message
*   -o | --output_dir   place to put extracted files. (creates output
                        dir structure here)
    -i | --input_file   only extract one file (output to output_dir)
    -d | --input_dir    extract all files in dir (recursively)
    -s | --systemid_conf specify config file of sysid <-> name mappings, to
                        give friendly names to BIOS RPMS.
    -t| --force_type   to build RPMs for firmwares apart from bios and raid

-- Required parameters are denoted by an asterisk (*)

"""

from __future__ import generators

version = "1.10"

# import arranged alphabetically
import ConfigParser
import fcntl
import getopt
import glob
import os
import Queue
import random
import shutil
import string
import sys
from threading import Thread
import time
import traceback
import xmlrpclib

import dell_repo_tools.ini_thread_proxy
import firmwaretools.pycompat as pycompat
import dell_repo_tools.extract_common
import firmwaretools.trace_decorator as trace_decorator
from firmwaretools.trace_decorator import trace

processFunctions = []
versionArray = []
modules = [ "firmware_addon_dell.extract_bios", "dell_bmc.extract_bmc", "dell_lsi.extract_lsi" ]

unableToProcessStr = "UNPROCESSED: Version %s unable to process"

@trace
def saveTerminalOutput():
    newStdoutFd = os.dup(sys.stdout.fileno())
    newStderrFd = os.dup(sys.stderr.fileno())
    return (
        os.fdopen(newStdoutFd, "a"),
        os.fdopen(newStderrFd, "a")
        )

@trace
def restoreTerminalOutput(realStdout, realStderr):
    os.dup2( realStdout.fileno(), 1 )
    os.dup2( realStderr.fileno(), 2 )
    sys.stdout=realStdout
    sys.stderr=realStderr

@trace
def checkAlreadyProcessed(ini, filename, outputDir, numFiles, thisNum, stdout, stderr):
    global forceRebuild
    outPrefix = "%04i/%04i %s File: %s" % (thisNum, numFiles, os.getpid(), filename)
    if ini.has_option("processed_files", filename) and not forceRebuild:
        procString = ini.get("processed_files", filename)

        if procString == unableToProcessStr:
            stdout.write("%s Version %s not able to process...\n" % (outPrefix, version))
            stdout.flush()
            return 1

        try:
            if procString.startswith("PROCESSED(%s):" % version):
                functName = procString.split(":")[1].strip()
                functVer  = procString.split(":")[2].strip()
                for funcDetails in processFunctions:
                    if funcDetails["functionName"] == functName and funcDetails["version"] == functVer:
                        stdout.write("%s Already processed by this version, skipping...\n" % outPrefix)
                        stdout.flush()
                        return 1
        except IndexError:
            pass

    return 0


@trace
def extractHdr(ini, filename, outputDir, numFiles, thisNum, stdout, stderr):
    ret = 0
    global version
    outPrefix = "%04i/%04i %s File: %s" % (thisNum, numFiles, os.getpid(), filename)

    tempdir=None
    try:
        oldpwd = os.getcwd()

        for funcDetails in processFunctions:
            try:
                if not filename.lower().endswith(funcDetails["extension"]):
                    continue
                else:
                    if tempdir is None:
                        tempdir = pycompat.mktempdir()
                        destFile = os.path.join(tempdir, os.path.basename(filename))
                        pycompat.copyFile(filename, destFile)
                        os.chdir(tempdir)

                ret = funcDetails["function"](ini, filename, destFile, outputDir, stdout, stderr)
                if ret:
                    ini.set("processed_files", filename, "PROCESSED(%s): %s:%s" % (version, funcDetails["functionName"], funcDetails["version"]))
                    stdout.write("%s good: %s\n" % (outPrefix, funcDetails["functionName"]))
                    break

            except dell_repo_tools.extract_common.skip:
                pass
            except (KeyboardInterrupt,), e:
                print "Caught <CTRL>-C. Exiting, please wait."
                raise
            except (Exception,), e:
                traceback.print_exc()
                pass

    finally:
        stdout.flush()
        os.chdir(oldpwd)
        if tempdir is not None:
            os.system("chmod -R u+rw %s" % tempdir)
            shutil.rmtree(tempdir)

    if not ret:
        stdout.write("%s: unable to process\n" % outPrefix)
        ini.set("processed_files", filename, unableToProcessStr)

    stdout.flush()
    return ret

@trace
def shutdownXmlRpcThread(xmlHandle, threadHandle):
    threadHandle.sync()
    threadHandle.kill()
    while threadHandle.threadcount:
        try:
            # need to process at least one request for xmlrpcserver to end
            xmlHandle.kill()
        except:
            pass
        print "waiting for thread to die."
        time.sleep(2)


forceRebuild = 0
def main():
    inputDir=[]
    inputFiles=[]
    outputDir=None
    forceType=None
    ini = None
    dell_repo_tools.extract_common.systemConfIni = ConfigParser.ConfigParser()

    iniThread = None
    numProcesses = 30
    realStdout, realStderr = saveTerminalOutput()

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hd:i:o:s:ft:vp:", [
                "help", "input_file=", "output_dir=",
                "systemid_conf=", "force", "input_dir=", "force_type=",
                "parallel=",
            ])
        for option, argument in opts:
            if option in ("-h", "--help"):
                print __doc__
                sys.exit(0)
            if option in ("-o", "--output_dir"):
                outputDir = argument
            if option in ("-p", "--parallel"):
                numProcesses = argument
            if option in ("-f", "--force"):
                global forceRebuild
                forceRebuild = 1
            if option in ("-i", "--input_file"):
                for f in glob.glob(os.path.realpath(argument)):
                    inputFiles.append(os.path.realpath(f))
            if option in ("-d", "--input_dir"):
                inputDir.append(argument)
            if option in ("-s", "--systemid_conf"):
                print "reading config file: %s" % argument
                dell_repo_tools.extract_common.systemConfIni.read(glob.glob(os.path.realpath(argument)))
            if option in ("-t", "--force_type"):
                forceType=str("%s" % argument)
                modules.append(forceType)
            if option in ("-v", "--verbose"):
                trace_decorator.debug["__main__"] = 9

        if outputDir is None: raise getopt.GetoptError("Need output dir", "")

        global processFunctions, versionArray, unableToProcessStr
        for m in modules:
            try:
                module = __import__(m, globals(), locals(), [])
                for i in m.split(".")[1:]:
                    module = getattr(module, i)
                versionArray.append( (m, module.version))
                if hasattr(module, "processFunctions"):
                    for funcDetails in module.processFunctions:
                        if not funcDetails.has_key("function"):
                            funcDetails["function"] = getattr(module, funcDetails["functionName"])
                        processFunctions.append(funcDetails)
            except:
                realStderr.write( "Warning: Unable to load module %s" % (m))
                
        unableToProcessStr = unableToProcessStr % versionArray

        outputDir = os.path.realpath(outputDir)
        if not os.path.exists(outputDir):
            os.makedirs(outputDir)

        if not os.access(os.path.join(outputDir,"log"), os.F_OK):
            os.mkdir(os.path.join(outputDir,"log"))

        ini = ConfigParser.ConfigParser()
        ini.read( os.path.join(outputDir, "config.ini"))
        if not ini.has_section("processed_files"):
            ini.add_section("processed_files")

        if not ini.has_section("out_files"):
            ini.add_section("out_files")

        if not ini.has_section("main"):
            ini.add_section("main")

        port = random.randrange(16384, 32767)
        iniThread = dell_repo_tools.ini_thread_proxy.XmlRpcThread(threadNumber=0, port=port, iniPath=os.path.join(outputDir, "config.ini"), ini=ini)
        ini = xmlrpclib.Server('http://localhost:%s' % port)

        start = time.time()
        while not iniThread.running:
            time.sleep(0.1)
            if (time.time() - start > 2):
                print "timeout waiting for config parser to startup"
                raise KeyboardInterrupt()

        for argument in inputDir:
            print "walking input directories"
            for topdir, dirlist, filelist in pycompat.walkPath(os.path.realpath(argument)):
                filelist.sort()
                for file in filelist:
                    inputFiles.append(os.path.join(topdir,file))
            print "done processing input directories"
            sys.stdout.flush()

        for i in (sys.stdout, sys.stderr, realStdout, realStderr): i.flush()

        children=[]
        inputFiles.sort()
        numInputFiles = len(inputFiles)
        for index in xrange(numInputFiles):
            # reset logging to new file
            hdrFile = inputFiles[index]
            hdrFileName=os.path.basename(hdrFile)
            logFileName = os.path.join(outputDir, "log", "%s-LOG" % hdrFileName)
            try:
                sys.stdout = open( logFileName, "w+" )
                sys.stderr = sys.stdout
                os.dup2( sys.stdout.fileno(), 1 )
                os.dup2( sys.stderr.fileno(), 2 )
            except IOError:
                pass

            if checkAlreadyProcessed(ini, hdrFile, outputDir, thisNum=index, numFiles=numInputFiles, stdout=realStdout, stderr=realStderr):
                continue

            # only spawn configured number of children at once
            while len(children) > numProcesses:
                child, status = os.waitpid(0,0)
                children.remove(child)
            else:
                # or or more children finished, sync config file
                iniThread.sync()

            for i in (sys.stdout, sys.stderr, realStdout, realStderr): i.flush()
            pid = os.fork()
            if pid: # parent
                children.append(pid)
            else: #child
                try:
                    # make sure we close inherited filehandles
                    # or we could hold open sockets, etc.
                    for i in xrange(sys.stderr.fileno()+1,255):
                        try:
                            os.close(i)
                        except OSError:
                            pass

                    extractHdr(ini, hdrFile, outputDir, thisNum=index, numFiles=numInputFiles, stdout=realStdout, stderr=realStderr)
                    if sys.stdout.tell() == 0:
                        os.unlink(logFileName)
                except:
                    realStderr.write(traceback.format_exc())

                for i in (sys.stdout, sys.stderr, realStdout, realStderr): i.flush()
                os._exit(0)

        #make print work again...
        for i in (sys.stdout, sys.stderr, realStdout, realStderr): i.flush()
        restoreTerminalOutput(realStdout, realStderr)

        #wait for everybody to finish up.
        iniThread.sync()
        while len(children):
            child, status = os.waitpid(0,0)
            children.remove(child)

        shutdownXmlRpcThread(ini, iniThread)
        realStdout.write( "Finished in %s seconds\n" % (time.time() - start))

    except (getopt.GetoptError):
        restoreTerminalOutput(realStdout, realStderr)
        # print help information and exit:
        realStdout.write( __doc__ + "\n")
        sys.exit(2)

    except (KeyboardInterrupt):
        restoreTerminalOutput(realStdout, realStderr)
        try:
            realStdout.write( "kill ini thread.\n")
            shutdownXmlRpcThread(ini, iniThread)
            realStdout.write( "wait for all children to finish\n")
            os.wait()
        except:
            realStderr.write(traceback.format_exc())

        sys.exit(3)

    except Exception:
        restoreTerminalOutput(realStdout, realStderr)
        if iniThread is not None:
            shutdownXmlRpcThread(ini, iniThread)
        realStderr.write(traceback.format_exc())

    return 0 #shell logic

if __name__ == "__main__":
    sys.exit( main() )
